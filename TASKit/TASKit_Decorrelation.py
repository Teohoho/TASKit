import simtk.openmm.app
import simtk.openmm
from simtk.unit import *

import mdtraj as md
import numpy as np

import pymbar.timeseries
import matplotlib.pyplot as plt

class DecorrelateTimeseries:

    def __init__(self, timeseries, stride=1):
        """A method that takes a timeseries and detects the equilibration point, calculates 
        the statistical inefficiency and the effective sample size, using PyMBAR.
         
        Parameters
        ----------
        
        timeseries: numpy.ndarray
            A numpy array that contains the timeseries to be used. If None, then the one generated by the
                getPotentialEnergy will be used.
            
        """
        
        self.timeseries_Corr = timeseries[::stride]
            
        [self.Eq_point, self.statIneff, self.Neff_Max] = pymbar.timeseries.detectEquilibration(self.timeseries_Corr, nskip=1)
        self.timeseries_Decorr = self.timeseries_Corr[self.Eq_point:]
        
        print ("The equilibration is done at sample number {}, the statistical inefficiency for the post-Eq region is {} and the" +
                        "number of Decorrelated samples in the post-Eq region is {}".format(self.Eq_point, self.statIneff, self.Neff_Max))
         
    def GenerateNEFFPlot(self, fig=None):
    
        """A method that generates the Effective Sample Size vs. Equilibration Point plot. Uses matplotlib.pyplot
             
        Parameters
        ----------
        
        fig: str    
            Save the figure to this filename. If None, then it will be showed on-screen.
        
        """
       
        NOfSamples = self.timeseries_Corr.shape[0]
        g_t    = np.ones(NOfSamples - 1)
        Neff_t = np.ones(NOfSamples - 1)
        for t in range(NOfSamples - 1):
            g_t[t] = pymbar.timeseries.statisticalInefficiency(self.timeseries_Corr[t:NOfSamples], fast=True)

            Neff_t[t] = (NOfSamples - t +1)/ g_t[t]

        ##Plot the Neff
        plt.plot(Neff_t, color="k")

        ##Plot a long red line where NeffMax is
        plt.plot([self.Eq_point, self.Eq_point], [0, self.Neff_Max+(self.Neff_Max*0.1)], color="r", linewidth=2)
        
        plt.ylim(0, self.Neff_Max+(self.Neff_Max*0.1))
        
        plt.xlabel("Step",         fontsize=18, labelpad=22)
        plt.ylabel("Neff samples", fontsize=18, labelpad=22)

        plt.xticks(fontsize=14)
        plt.yticks(fontsize=14)
        
        if (fig is not None):
            plt.tight_layout(pad=0.5)
            plt.savefig(fig, dpi=800)
        else:
            plt.show()
                         
    def GetDecorrSamples(self, log=None):
    
        """A method that generates a list containing the Decorrelated Sample Indices, given the decorrelated timeseries and 
            the statistical inefficiency.
             
        Parameters
        ----------
        
        log: str    
            Save the log to this file.
        
        """
     
        decorrelatedSampleIndices = pymbar.timeseries.subsampleCorrelatedData(self.timeseries_Decorr, g=self.statIneff)
        decorrelatedSamples = self.timeseries_Decorr[decorrelatedSampleIndices]
        
        if (log is not None):
            with open(log, "w") as OutFN:
                for i in range(decorrelatedSamples.shape[0]):
                    OutFN.write(str(decorrelatedSampleIndices[i] + self.Eq_point))
                    OutFN.write(" ")
                OutFN.close()
        
        decorrelatedSampleIndicesAll = np.add(decorrelatedSampleIndices, self.Eq_point)
        
        self.decorrelatedSampleIndicesAll = decorrelatedSampleIndicesAll
        
        return decorrelatedSampleIndicesAll     
   
def QuickTrim(prmtop, dcdIn, dcdOut=None, stride=1, plot=True):

    """A shortcut function that does what most users will want to do with this
        class. Uses most common options.

    Parameters
    ----------
    
    prmtop: str
             A list object containing the PRMTOPs of the systems for which RMSDS
             will be calculated
             
    dcdIn: list or str
             A DCD or a list of DCDs to be loaded into the prmtop

    stride: int, default=1
             Use this stride when loading the trajectories to sparsify the trajectories
             
    onlyProt: bool, default=True   
             If true, then load only the protein atoms. This saves memory, since most
             DCDs also contain more water atoms than protein atoms and often we want 
             the energy of the protein, without solvent contribution.
             
    plot: bool, default=True
            If True, then it will display the plot that would be generated by
            GenerateNEFFPlot.
            
    """

    InitTraj = DecorrelateTrajectory(prmtop=prmtop, DCDS=dcdIn, stride=stride)
    InitTraj.GetPotentialEnergies()
    InitTraj.TimeseriesDecorrelation()
    
    if (plot == True):
        InitTraj.GenerateNEFFPlot()
     
    InitTraj.GetDecorrSamples()
     
    TrimmedTraj = InitTraj.TrimTraj(dcdOut=dcdOut)
    
    return(TrimmedTraj)