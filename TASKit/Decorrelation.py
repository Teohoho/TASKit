#imports
import pymbar.timeseries
import matplotlib.pyplot as plt


class DecorrelateTimeseries:

    def __init__(self, TSIn, stride=1):
        """A method that takes a timeseries and detects the equilibration point, calculates 
        the statistical inefficiency and the effective sample size, using PyMBAR.
         
        Parameters
        ----------
        
        TSIn: numpy.ndarray
            A numpy array that contains the timeseries to be used. If None, then the one generated by the
                getPotentialEnergy will be used.
            
        """
        
        self.timeseries_Corr = TSIn[::stride]
            
        [self.Eq_point, self.statIneff, self.Neff_Max] = pymbar.timeseries.detectEquilibration(self.timeseries_Corr, nskip=1)
        self.timeseries_Decorr = self.timeseries_Corr[self.Eq_point:]
        
        print ("The equilibration is done at sample number {}, the statistical inefficiency for the post-Eq region is {} and the" +
                        "number of Decorrelated samples in the post-Eq region is {}".format(self.Eq_point, self.statIneff, self.Neff_Max))
         
    def GenerateNEFFPlot(self, fig=None):
    
        """A method that generates the Effective Sample Size vs. Equilibration Point plot. Uses matplotlib.pyplot
             
        Parameters
        ----------
        
        fig: str    
            Save the figure to this filename. If None, then it will be showed on-screen.
        
        """
       
        NOfSamples = self.timeseries_Corr.shape[0]
        g_t    = np.ones(NOfSamples - 1)
        Neff_t = np.ones(NOfSamples - 1)
        for t in range(NOfSamples - 1):
            g_t[t] = pymbar.timeseries.statisticalInefficiency(self.timeseries_Corr[t:NOfSamples], fast=True)

            Neff_t[t] = (NOfSamples - t +1)/ g_t[t]

        ##Plot the Neff
        plt.plot(Neff_t, color="k")

        ##Plot a long red line where NeffMax is
        plt.plot([self.Eq_point, self.Eq_point], [0, self.Neff_Max+(self.Neff_Max*0.1)], color="r", linewidth=2)
        
        plt.ylim(0, self.Neff_Max+(self.Neff_Max*0.1))
        
        plt.xlabel("Step",         fontsize=18, labelpad=22)
        plt.ylabel("Neff samples", fontsize=18, labelpad=22)

        plt.xticks(fontsize=14)
        plt.yticks(fontsize=14)
        
        if (fig is not None):
            plt.tight_layout(pad=0.5)
            plt.savefig(fig, dpi=800)
        else:
            plt.show()
                         
    def GetDecorrSamples(self, log=None):
    
        """A method that generates a list containing the Decorrelated Sample Indices, given the decorrelated timeseries and 
            the statistical inefficiency.
             
        Parameters
        ----------
        
        log: str    
            Save the log to this file.
        
        """
     
        decorrelatedSampleIndices = pymbar.timeseries.subsampleCorrelatedData(self.timeseries_Decorr, g=self.statIneff)
        decorrelatedSamples = self.timeseries_Decorr[decorrelatedSampleIndices]
        
        if (log is not None):
            with open(log, "w") as OutFN:
                for i in range(decorrelatedSamples.shape[0]):
                    OutFN.write(str(decorrelatedSampleIndices[i] + self.Eq_point))
                    OutFN.write(" ")
                OutFN.close()
        
        decorrelatedSampleIndicesAll = np.add(decorrelatedSampleIndices, self.Eq_point)
        
        self.decorrelatedSampleIndicesAll = decorrelatedSampleIndicesAll
        
        return decorrelatedSampleIndicesAll     