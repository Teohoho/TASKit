##Licence notices
#    TASKit: A Python-based kit containing Post-MD analysis tools.
#    Copyright (C) 2020  È˜ulea Teodor Asvadur
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>

#imports
import pymbar.timeseries
import matplotlib.pyplot as plt
import numpy as np


class DecorrelateTimeseries:

    def __init__(self, TSIn, stride=1):
        """A method that takes a timeseries and detects the equilibration point, calculates 
        the statistical inefficiency and the effective sample size, using PyMBAR.
         
        Parameters
        ----------
        
        TSIn: numpy.ndarray
            A numpy array that contains the timeseries to be used. If None, then the one generated by the
                getPotentialEnergy will be used.
            
        """
        
        self.timeseries_Corr = TSIn[::stride]
            
        [self.Eq_point, self.statIneff, self.Neff_Max] = pymbar.timeseries.detectEquilibration(self.timeseries_Corr, nskip=1)
        self.timeseries_Decorr = self.timeseries_Corr[self.Eq_point:]
        
        print ("The equilibration is done at sample number {}, the statistical \
inefficiency for the post-Eq region is {} and the number of \
Decorrelated samples in the post-Eq region is {}".format(self.Eq_point,
self.statIneff, self.Neff_Max))

        self.stride = stride
         
    def GenerateNEFFPlot(self, fig=None):
    
        """A method that generates the Effective Sample Size vs. Equilibration Point plot. Uses matplotlib.pyplot
             
        Parameters
        ----------
        
        fig: str    
            Save the figure to this filename. If None, then it will be showed on-screen.
        
        """
       
        NOfSamples = self.timeseries_Corr.shape[0]
        g_t    = np.ones(NOfSamples - 1)
        Neff_t = np.ones(NOfSamples - 1)
        for t in range(NOfSamples - 1):
            g_t[t] = pymbar.timeseries.statisticalInefficiency(self.timeseries_Corr[t:NOfSamples], fast=True)

            Neff_t[t] = (NOfSamples - t +1)/ g_t[t]

        ##Plot the Neff
        plt.plot(Neff_t, color="k")

        ##Plot a long red line where NeffMax is
        plt.plot([self.Eq_point, self.Eq_point], [0, self.Neff_Max+(self.Neff_Max*0.1)], color="r", linewidth=2)
        
        plt.ylim(0, self.Neff_Max+(self.Neff_Max*0.1))
        
        plt.xlabel("Step",         fontsize=18, labelpad=22)
        plt.ylabel("Neff samples", fontsize=18, labelpad=22)

        plt.xticks(fontsize=14)
        plt.yticks(fontsize=14)
        
        if (fig is not None):
            plt.tight_layout(pad=0.5)
            plt.savefig(fig, dpi=800)
        else:
            plt.show()
                         
    def GetDecorrSamples(self, log=None):
    
        """A method that generates a list containing the Decorrelated Sample Indices, given the decorrelated timeseries and 
            the statistical inefficiency.
             
        Parameters
        ----------
        
        log: str    
            Save the log to this file.
        
        """
     
        decorrelatedSampleIndices = pymbar.timeseries.subsampleCorrelatedData(self.timeseries_Decorr, g=self.statIneff)
        self.decorrelatedSamples = self.timeseries_Decorr[decorrelatedSampleIndices]
        
        
        decorrelatedSampleIndicesAll = np.add(decorrelatedSampleIndices, self.Eq_point)
        decorrelatedSampleIndicesAll = np.multiply(decorrelatedSampleIndicesAll, self.stride) ##To get the actual frame numbers, independent of stride used
        
        if (log is not None):
            with open(log, "w") as OutFN:
                for i in range(decorrelatedSampleIndicesAll.shape[0]):
                    OutFN.write(str(decorrelatedSampleIndicesAll))
                    OutFN.write(" ")
                OutFN.close()
        
        
                
        return decorrelatedSampleIndicesAll     
